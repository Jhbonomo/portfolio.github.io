<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="What school teachers taught me about people and UX - A UX research case study on changing product design approaches through teacher interviews for edtech reading literacy">
    <meta name="keywords" content="UX Research, Product Design, User Experience, Case Study, EdTech, Reading Literacy, Teacher Interviews">
    <meta name="author" content="Juliana">
    <meta property="og:title" content="What school teachers taught me about people and UX - Juliana's Portfolio">
    <meta property="og:description" content="How I changed my approach to product design from user interviews with school teachers for an edtech for reading literacy">
    <meta property="og:type" content="article">
    <meta name="theme-color" content="#ffffff">
    <title>What school teachers taught me about people and UX - Juliana's Portfolio</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Zilla+Slab:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=Special+Elite&family=Roboto:ital,wght@0,100;0,300;0,400;0,500;0,700;0,900;1,100;1,300;1,400;1,500;1,700;1,900&family=Open+Sans:ital,wght@0,300;0,400;0,500;0,600;0,700;0,800;1,300;1,400;1,500;1,600;1,700;1,800&family=Lato:ital,wght@0,100;0,300;0,400;0,700;0,900;1,100;1,300;1,400;1,700;1,900&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Montserrat:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Raleway:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Ubuntu:ital,wght@0,300;0,400;0,500;0,700;1,300;1,400;1,500;1,700&family=Nunito:ital,wght@0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Playfair+Display:ital,wght@0,400;0,500;0,600;0,700;0,800;0,900;1,400;1,500;1,600;1,700;1,800;1,900&family=Merriweather:ital,wght@0,300;0,400;0,700;0,900;1,300;1,400;1,700;1,900&family=Source+Sans+Pro:ital,wght@0,200;0,300;0,400;0,600;0,700;0,900;1,200;1,300;1,400;1,600;1,700;1,900&family=Inter:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="../assets/css/project-template.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navigation">
        <a href="../index.html" class="back-link">‚Üê Back</a>
        <div class="header-controls">
            <button class="font-size-btn" id="fontSizeBtn">Aa</button>
            <button class="theme-toggle" id="themeToggle">üåô</button>
        </div>
    </nav>
    
    <div class="newspaper-container">
        <!-- Header -->
        <header class="newspaper-header">
            <div class="project-meta">
                <div class="project-categories">UX Research | Education</div>
                <h1 class="project-title">What school teachers taught me about people and UX</h1>
                <div class="project-subtitle">How I changed my approach to product design from user interviews with school teachers for an edtech for reading literacy</div>
                <div class="project-meta-info">
                    <span class="project-date">2022</span>
                    <span class="project-duration">UX research team</span>
                    <span class="project-role">Baires/Newsela</span>
                </div>
            </div>
        </header>

        <!-- Main Content -->
        <main class="newspaper-content">
            <!-- Executive Summary -->
            <section class="article-section">
                <h2 class="section-title">My role</h2>
                <div class="article-content">
                    <p >As a UX researcher contractor (BairesDev) I was part of the team conducting user interviews and research for Newsela, an edtech platform. From generative researches to product validations, we held user interviews with teachers to understand how they were using leveled-reading tools in their classrooms. </p>

                    <p>
                        These conversations took place in 2022, as students were returning to in-person learning post-pandemic and what emerged wasn't just a snapshot of product usage, it was a portrait of change that fundamentally shifted my understanding of the user experience of a product.
                    </p>

                </div>
            </section>

            <!-- The Challenge -->
            <section class="article-section">
                <h2 class="section-title">The Challenge</h2>
                <div class="article-content">
                    <p> Teachers described a classroom transformed: students returning with very uneven knowledge, fragmented focus, and varying levels of digital fluency and sociability. </p>
                    <p>
                         The challenge wasn't just about improving a product, it was about understanding how to support teachers and students navigating a post-pandemic educational landscape.</p>
                   
                </div>
            </section>

            <!-- The Discovery -->
            <section class="article-section">
                <h2 class="section-title">The Discovery</h2>
                <div class="article-content">
   
                          <p>      
                         Teaching became less about delivering information and more about meeting learners where they were, making space for exploration, and supporting different paths toward understanding.

                    </p>
                    
                    
                    <p>
                            That shift felt deeply familiar. The way teachers navigated these challenges echoed how users engage with digital systems: entering with different assumptions, skills, and needs, not as blank slates, but as learners in motion.
                        </p>
                    
                    <!-- Image: Education and UI Mediums Parallel -->
                    <div class="image-container">
                        <figcaption class="image-caption">
                            Flashcards on the left; UI cards on the right. Both use images to teach and show structure.                        
                        </figcaption>
                            <div class="image-wrapper" data-zoom="true">
                            <img src="../assets/images/Edtech/education and ux.png" 
                                 alt="Parallel between education mediums and user interface mediums - both rely on diverse formats to meet different learning and interaction needs" 
                                 class="interactive-image"
                                 loading="lazy">
                            <div class="image-overlay">
                                <button class="zoom-btn" title="Click to zoom">üîç</button>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- The Insight -->
            <section class="article-section">
                <h2 class="section-title">The Insight</h2>
                <div class="article-content">
                    <p>
                        I began to see the product through that lens: not as a tool to be used, but as a space to be experienced and made sense of. Using a product is often an act of learning, a non-linear process supported by guidance, exploration, uncovering, responding, and adapting.
                    </p>                       
                    <h3>Insights</h3>
                    <ul class="insights-list">
                         <li><strong>Spark Curiosity:</strong>Engagement is a key factor for how we learn more naturally. The more an interface succeeds in inviting users to explore, the more it turns browsing into genuine understanding.
                         </li>

                        <li><strong>Scaffolding Learning:</strong>Effective interfaces are supporting structures. They break down complex tasks like a great teacher, using guided flows that simplify processes, timely hints that act as just-in-time lessons, and progress tracking that builds confidence with each completed step.</li>
                       
                        
                        <li><strong>Meet where people are:</strong> Just as a skilled teacher adapts lessons to a student's prior knowledge, effective interfaces respond to user skill levels. They provide shortcuts for experts and guidance for newcomers, acknowledging that every user brings their own assumptions, skills, and needs.</li>
                    </ul>
 
                </div>
            </section>

            <!-- The Application -->
            <section class="article-section">
                <h2 class="section-title">Design that scaffolds learning</h2>
                <div class="article-content">
                    <p>
                        Issues like discoverability, engagement, and digital literacy aren't just usability problems; they're lessons to learn. Like a skilled teacher, thoughtful design can scaffold learning, spark curiosity, smooth the path, and ultimately build confidence.
                    </p>
                    <figcaption class="image-caption">Our perception is shaped by how things are presented to us. The example below shows how small typography tweaks can change how a message is understood</figcaption>
                     <!-- Accordion Section -->
                     <div class="accordion-container">
                         <div class="accordion">
                                                          <div class="accordion-item">
                                  <div class="accordion-header" onclick="toggleAccordion(this)">
                                      <h4>from Surface to sense</h4>
                                      <span class="accordion-icon">^</span>
                                  </div>
                                  <div class="accordion-content expanded">
                                      <div class="button-container" style="margin-top: 0.5rem;">
                                          <button class="font-reset-btn" onclick="fixFontProperties('surface-sense-paragraph')">Fix text</button>
                                          <button class="font-change-btn" onclick="randomizeFontProperties('surface-sense-paragraph')">Mess it up</button>
                                      </div>
                                      <p id="surface-sense-paragraph">When the surface fails, the sense is lost. Low contrast, cramped letters, and noisy fonts hide the message. Clarity is not decoration, it is the first step to learning.</p>
                                  </div>
                              </div>
                              
                              <div class="accordion-item">
                                  <div class="accordion-header" onclick="toggleAccordion(this)">
                                      <h4>from rhythm to Context</h4>
                                      <span class="accordion-icon">v</span>
                                  </div>
                                  <div class="accordion-content">
                                      <div class="switch-container">
                                          <label class="switch">
                                              <input type="checkbox" id="rhythmSwitch">
                                              <span class="slider"></span>
                                          </label>
                                          <span class="switch-label">Provide Rhythm</span>
                                      </div>
                                      
                                      <p>We internalize through rhythm. Broken lines, awkward spacing, or endless walls of text disrupt understanding. Good rhythm guides the eye, turning fragments into context.</p>
                                  </div>
                              </div>
                              
                              <div class="accordion-item">
                                  <div class="accordion-header" onclick="toggleAccordion(this)">
                                      <h4>from pattern to meaning</h4>
                                      <span class="accordion-icon">v</span>
                                  </div>
                                  <div class="accordion-content">
                                      <p>Meaning lives in patterns. Confusing buttons, inconsistent icons, or vanishing controls block action. Clear patterns invite trust, they let us act, not guess.</p>
                                      
                                      <div class="pattern-game-container">
                                          <div class="game-instructions">
                                              <p class="desktop-instructions">Use arrow keys to move the dot to the target:</p>
                                              <p class="mobile-instructions" style="display: none;">Swipe to move the dot to the target:</p>
                                          </div>
                                          <div class="game-area">
                                              <div id="gameDot" class="game-dot"></div>
                                              <div id="gameTarget" class="game-target"></div>
                                              <div class="on-screen-controls">
                                                  <div class="arrow-row">
                                                      <button class="arrow-btn" id="arrowUp" aria-label="Move up">‚Üë</button>
                                                  </div>
                                                  <div class="arrow-row">
                                                      <button class="arrow-btn" id="arrowLeft" aria-label="Move left">‚Üê</button>
                                                      <button class="arrow-btn" id="arrowDown" aria-label="Move down">‚Üì</button>
                                                      <button class="arrow-btn" id="arrowRight" aria-label="Move right">‚Üí</button>
                                                  </div>
                                              </div>
                                          </div>
                                          <div class="switch-container">
                                              <label class="switch">
                                                  <input type="checkbox" id="patternSwitch">
                                                  <span class="slider"></span>
                                              </label>
                                              <span class="switch-label">Fix Keyboard Settings</span>
                                          </div>

                                      </div>
                                  </div>
                              </div>
                         </div>
                     </div>
                </div>
            </section>



            <!-- Reflection -->
            <section class="article-section">
                <h2 class="section-title">Reflection & Learnings</h2>
                <div class="article-content">
                    <p>
                        Thank you for reading this case study.  The principles of scaffolding, guidance, and adaptability I learned from educators now fundamentally shape my design philosophy.
                    </p>
                    
                    <div class="learning-highlight">
                        <h3>Key Learnings</h3>
                        <ul>
                            <li>I now approach every UX research project as a learning journey, not just a task analysis</li>
                            <li>Design solutions focus on scaffolding and guidance rather than just efficiency</li>
                            <li>User interviews explore adaptation patterns and growth, not just feature preferences</li>
                            
                        </ul>
                    </div>
                </div>
            </section>
        </main>

        <!-- Footer -->
        <footer class="newspaper-footer">
            <div class="footer-content">
                <p>Thank you for reading this case study.This project revealed a core truth: great UX is great teaching. The principles of scaffolding, guidance, and adaptability I learned from educators now fundamentally shape my design philosophy. Let's discuss how these ideas can elevate your next project.

                </p>
                <div class="footer-links">
                    <a href="https://www.linkedin.com/in/julianahb/" target="_blank" rel="noopener noreferrer">LinkedIn</a>
                </div>
            </div>
        </footer>
    </div>

    <!-- Image Zoom Modal -->
    <div class="image-modal" id="imageModal">
        <div class="modal-content">
            <button class="modal-close" id="modalClose">&times;</button>
            <div class="modal-image-container">
                <img id="modalImage" src="" alt="">
            </div>
            <div class="modal-controls">
                <button class="zoom-control" id="zoomIn">+</button>
                <button class="zoom-control" id="zoomOut">‚àí</button>
                <button class="zoom-control" id="resetZoom">Reset</button>
            </div>
        </div>
    </div>

        <script src="../assets/js/project-template.js"></script>
        
        <script>
            function toggleAccordion(header) {
                const accordionItem = header.parentElement;
                const content = accordionItem.querySelector('.accordion-content');
                const icon = header.querySelector('.accordion-icon');
                
                // Close all other accordion items
                const allAccordionItems = document.querySelectorAll('.accordion-item');
                allAccordionItems.forEach(item => {
                    if (item !== accordionItem) {
                        const otherContent = item.querySelector('.accordion-content');
                        const otherIcon = item.querySelector('.accordion-icon');
                        otherContent.classList.remove('expanded');
                        otherIcon.textContent = 'v';
                    }
                });
                
                // Toggle current item
                if (content.classList.contains('expanded')) {
                    content.classList.remove('expanded');
                    icon.textContent = 'v';
                } else {
                    content.classList.add('expanded');
                    icon.textContent = '^';
                }
            }

            function randomizeFontProperties(elementId) {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Random font size (very small or very large)
                const fontSizes = ['0.5rem', '0.6rem', '0.7rem', '3rem', '4rem', '5rem', '6rem'];
                const randomSize = fontSizes[Math.floor(Math.random() * fontSizes.length)];
                
                // Random Google Font families
                const fontFamilies = [
                    'Roboto, sans-serif',
                    'Open Sans, sans-serif',
                    'Lato, sans-serif',
                    'Poppins, sans-serif',
                    'Montserrat, sans-serif',
                    'Raleway, sans-serif',
                    'Ubuntu, sans-serif',
                    'Nunito, sans-serif',
                    'Playfair Display, serif',
                    'Merriweather, serif',
                    'Source Sans Pro, sans-serif',
                    'Inter, sans-serif'
                ];
                const randomFont = fontFamilies[Math.floor(Math.random() * fontFamilies.length)];
                
                // Random opposite gray shades
                const grayShades = [
                    '#1a1a1a', // Very dark gray
                    '#2d2d2d', // Dark gray
                    '#404040', // Medium dark gray
                    '#666666', // Medium gray
                    '#999999', // Light gray
                    '#cccccc', // Very light gray
                    '#e6e6e6'  // Almost white gray
                ];
                const randomColor = grayShades[Math.floor(Math.random() * grayShades.length)];
                
                // Random line heights (very tight to very loose)
                const lineHeights = ['0.8', '1.0', '1.2', '2.0', '2.5', '3.0'];
                const randomLineHeight = lineHeights[Math.floor(Math.random() * lineHeights.length)];
                
                // Apply random properties
                element.style.fontSize = randomSize;
                element.style.fontFamily = randomFont;
                element.style.color = randomColor;
                element.style.lineHeight = randomLineHeight;
                
                // Add a subtle animation effect
                element.style.transition = 'all 0.3s ease';
                element.style.transform = 'scale(1.02)';
                
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                }, 300);
            }

            function resetFontProperties(elementId) {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Reset to original properties
                element.style.fontSize = '';
                element.style.fontFamily = '';
                element.style.fontFamily = '';
                element.style.color = '';
                element.style.lineHeight = '';
                element.style.transform = '';
                
                // Add a subtle animation effect
                element.style.transition = 'all 0.3s ease';
                element.style.transform = 'scale(0.98)';
                
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                }, 300);
            }

            function fixFontProperties(elementId) {
                const element = document.getElementById(elementId);
                if (!element) return;

                // Fix to good typography properties
                element.style.fontSize = '1.1rem';
                element.style.fontFamily = 'Zilla Slab, Georgia, serif';
                element.style.color = '#2c2c2c';
                element.style.lineHeight = '1.6';
                element.style.letterSpacing = '';
                element.style.transform = '';
                
                // Add a subtle animation effect
                element.style.transition = 'all 0.3s ease';
                element.style.transform = 'scale(1.02)';
                
                setTimeout(() => {
                    element.style.transform = 'scale(1)';
                }, 300);
            }

            // Set initial weird state for surface-sense paragraph
            document.addEventListener('DOMContentLoaded', function() {
                const surfaceSenseParagraph = document.getElementById('surface-sense-paragraph');
                if (surfaceSenseParagraph) {
                    // Apply weird initial state
                    surfaceSenseParagraph.style.fontSize = '9px';
                    surfaceSenseParagraph.style.lineHeight = '0.8';
                    surfaceSenseParagraph.style.color = '#999999';
                    surfaceSenseParagraph.style.letterSpacing = '-5%';
                }
                
                // Rhythm toggle functionality
                const rhythmSwitch = document.getElementById('rhythmSwitch');
                const rhythmContent = rhythmSwitch.closest('.accordion-content');
                
                // Only apply styling if accordion is expanded
                function applyDisruptedStyling() {
                    if (rhythmContent.classList.contains('expanded')) {
                        rhythmContent.style.transition = 'all 0.5s ease';
                        rhythmContent.style.letterSpacing = '0.3em';
                        rhythmContent.style.wordSpacing = '0.5em';
                        rhythmContent.style.lineHeight = '0.8';
                        rhythmContent.style.textAlign = 'justify';
                        rhythmContent.style.fontFamily = 'Courier, monospace';
                        rhythmContent.style.fontSize = '0.9rem';
                        rhythmContent.style.color = '#666';
                        rhythmContent.style.padding = '0.5rem 1rem';
                        rhythmContent.style.border = 'none';
                        rhythmContent.style.borderRadius = '0';
                        rhythmContent.style.backgroundColor = '#f9f9f9';
                        
                        // Add some random spacing to paragraphs
                        const paragraphs = rhythmContent.querySelectorAll('p');
                        paragraphs.forEach((p, index) => {
                            p.style.marginBottom = index % 2 === 0 ? '3rem' : '0.5rem';
                            
                            // Ensure no line break in initial state
                            if (p.innerHTML.includes('disrupt understanding.<br>Good rhythm')) {
                                p.innerHTML = p.innerHTML.replace(
                                    'disrupt understanding.<br>Good rhythm',
                                    'disrupt understanding. Good rhythm'
                                );
                            }
                            
                            // Ensure no line breaks in initial state
                            if (p.innerHTML.includes('<p>We internalize through rhythm.</p>')) {
                                p.innerHTML = 'We internalize through rhythm. Broken lines, awkward spacing, or endless walls of text disrupt understanding. Good rhythm guides the eye, turning fragments into context.';
                            }
                        });
                    }
                }
                
                // Apply initial styling only if expanded
                applyDisruptedStyling();
                
                // Listen for accordion expansion/collapse
                const accordionHeader = rhythmContent.previousElementSibling;
                if (accordionHeader) {
                    accordionHeader.addEventListener('click', function() {
                        // Small delay to let the accordion toggle complete
                        setTimeout(applyDisruptedStyling, 100);
                    });
                }
                
                rhythmSwitch.addEventListener('change', function() {
                    if (this.checked) {
                        // Provide rhythm - apply good typography styling
                        rhythmContent.style.transition = 'all 0.5s ease';
                        rhythmContent.style.letterSpacing = '';
                        rhythmContent.style.wordSpacing = '';
                        rhythmContent.style.lineHeight = '1.6';
                        rhythmContent.style.textAlign = 'left';
                        rhythmContent.style.fontFamily = 'Zilla Slab, Georgia, serif';
                        rhythmContent.style.fontSize = '1.1rem';
                        rhythmContent.style.color = '#2c2c2c';
                        rhythmContent.style.padding = '0.5rem 1rem';
                        rhythmContent.style.border = 'none';
                        rhythmContent.style.borderRadius = '';
                        rhythmContent.style.backgroundColor = '';
                        
                        // Apply consistent spacing to paragraphs and add line break
                        const paragraphs = rhythmContent.querySelectorAll('p');
                        paragraphs.forEach((p, index) => {
                            p.style.marginBottom = '1rem';
                            p.style.paddingLeft = '';
                            
                            // Add line break between "disrupt understanding" and "Good rhythm"
                            if (p.textContent.includes('disrupt understanding')) {
                                p.innerHTML = p.textContent.replace(
                                    'disrupt understanding. Good rhythm',
                                    'disrupt understanding.<br>Good rhythm'
                                );
                            }
                            
                            // Add line breaks in the exact format requested
                            if (p.textContent.includes('We internalize through rhythm')) {
                                p.innerHTML = '<p>We internalize through rhythm.</p><p>Broken lines, awkward spacing, or endless walls of text disrupt understanding.</p><p>Good rhythm guides the eye, turning fragments into context.</p>';
                            }
                        });
                        
                    } else {
                        // Break the rhythm - apply disruptive styling
                        rhythmContent.style.transition = 'all 0.5s ease';
                        rhythmContent.style.letterSpacing = '0.3em';
                        rhythmContent.style.wordSpacing = '0.5em';
                        rhythmContent.style.lineHeight = '0.8';
                        rhythmContent.style.textAlign = 'justify';
                        rhythmContent.style.fontFamily = 'Courier, monospace';
                        rhythmContent.style.fontSize = '0.9rem';
                        rhythmContent.style.color = '#666';
                        rhythmContent.style.padding = '0.5rem 1rem';
                        rhythmContent.style.border = 'none';
                        rhythmContent.style.borderRadius = '0';
                        rhythmContent.style.backgroundColor = '#f9f9f9';
                        
                        // Add some random spacing to paragraphs and remove line break
                        const paragraphs = rhythmContent.querySelectorAll('p');
                        paragraphs.forEach((p, index) => {
                            p.style.marginBottom = index % 2 === 0 ? '3rem' : '0.5rem';
                            
                            // Remove line break and restore original text
                            if (p.innerHTML.includes('disrupt understanding.<br>Good rhythm')) {
                                p.innerHTML = p.innerHTML.replace(
                                    'disrupt understanding.<br>Good rhythm',
                                    'disrupt understanding. Good rhythm'
                                );
                            }
                            
                            // Remove line breaks and restore original text
                            if (p.innerHTML.includes('<p>We internalize through rhythm.</p>')) {
                                p.innerHTML = 'We internalize through rhythm. Broken lines, awkward spacing, or endless walls of text disrupt understanding. Good rhythm guides the eye, turning fragments into context.';
                            }
                        });
                    }
                });
            });
            
            // Pattern game functionality
            document.addEventListener('DOMContentLoaded', function() {
                // Show appropriate instructions based on device
                const desktopInstructions = document.querySelector('.desktop-instructions');
                const mobileInstructions = document.querySelector('.mobile-instructions');
                
                if (window.innerWidth <= 768) {
                    // Mobile device
                    if (desktopInstructions) desktopInstructions.style.display = 'none';
                    if (mobileInstructions) mobileInstructions.style.display = 'block';
                } else {
                    // Desktop device
                    if (desktopInstructions) desktopInstructions.style.display = 'block';
                    if (mobileInstructions) mobileInstructions.style.display = 'none';
                }
                const gameDot = document.getElementById('gameDot');
                const gameArea = document.querySelector('.game-area');
                const patternSwitch = document.getElementById('patternSwitch');
                
                // Game logic for both desktop and mobile
                if (gameDot && gameArea) {
                    let dotX = 50; // Start at center
                    let dotY = 50;
                    const stepSize = 5;
                    let controlsFixed = false;
                    
                    function updateDotPosition() {
                        gameDot.style.left = dotX + '%';
                        gameDot.style.top = dotY + '%';
                    }
                    
                    function getRandomPosition() {
                        return {
                            x: Math.floor(Math.random() * 60) + 20, // 20-80%
                            y: Math.floor(Math.random() * 60) + 20  // 20-80%
                        };
                    }
                    
                    function getRandomPositionAwayFromTarget(targetX, targetY, minDistance = 60) {
                        let newPos;
                        let attempts = 0;
                        const maxAttempts = 50;
                        
                        do {
                            newPos = {
                                x: Math.floor(Math.random() * 60) + 20, // 20-80%
                                y: Math.floor(Math.random() * 60) + 20  // 20-80%
                            };
                            attempts++;
                            
                            // Calculate distance from target
                            const distance = Math.sqrt(
                                Math.pow(newPos.x - targetX, 2) + 
                                Math.pow(newPos.y - targetY, 2)
                            );
                            
                            // If we found a position far enough away, use it
                            if (distance >= minDistance) {
                                return newPos;
                            }
                        } while (attempts < maxAttempts);
                        
                        // If we can't find a good position after many attempts, 
                        // place it at the opposite corner
                        return {
                            x: targetX > 50 ? 20 : 80,
                            y: targetY > 50 ? 20 : 80
                        };
                    }
                    
                    function moveTargetToRandomPosition() {
                        const target = document.getElementById('gameTarget');
                        const pos = getRandomPosition();
                        target.style.top = pos.y + '%';
                        target.style.left = pos.x + '%';
                    }
                    
                    function checkWin() {
                        const targetRect = document.getElementById('gameTarget').getBoundingClientRect();
                        const dotRect = gameDot.getBoundingClientRect();
                        
                        const distance = Math.sqrt(
                            Math.pow(dotRect.left - targetRect.left, 2) + 
                            Math.pow(dotRect.top - targetRect.top, 2)
                        );
                        
                        if (distance < 30) {
                            setTimeout(() => {
                                if (controlsFixed) {
                                    alert('üéâ Perfect! Clear patterns make it easy to reach your goal.');
                                } else {
                                    alert('üéâ You reached the target! But notice how confusing the random controls were...');
                                }
                                // Reset positions
                                moveTargetToRandomPosition();
                                
                                // Get new target position and place red dot away from it
                                const target = document.getElementById('gameTarget');
                                const targetRect = target.getBoundingClientRect();
                                const gameAreaRect = gameArea.getBoundingClientRect();
                                
                                // Convert target position to percentage
                                const targetXPercent = ((targetRect.left - gameAreaRect.left) / gameAreaRect.width) * 100;
                                const targetYPercent = ((targetRect.top - gameAreaRect.top) / gameAreaRect.height) * 100;
                                
                                // Get position away from target
                                const safePos = getRandomPositionAwayFromTarget(targetXPercent, targetYPercent, 40);
                                dotX = safePos.x;
                                dotY = safePos.y;
                                updateDotPosition();
                            }, 100);
                        }
                    }
                    
                    // Handle toggle
                    if (patternSwitch) {
                        patternSwitch.addEventListener('change', function() {
                            controlsFixed = this.checked;
                        });
                    }
                    
                    document.addEventListener('keydown', function(e) {
                        if (e.key.startsWith('Arrow')) {
                            e.preventDefault();
                            
                            if (controlsFixed) {
                                // Fixed pattern: normal controls
                                switch(e.key) {
                                    case 'ArrowLeft':
                                        dotX = Math.max(5, dotX - stepSize); // Goes left
                                        break;
                                    case 'ArrowRight':
                                        dotX = Math.min(95, dotX + stepSize); // Goes right
                                        break;
                                    case 'ArrowUp':
                                        dotY = Math.max(5, dotY - stepSize); // Goes up
                                        break;
                                    case 'ArrowDown':
                                        dotY = Math.min(95, dotY + stepSize); // Goes down
                                        break;
                                }
                            } else {
                                // Confusing pattern: random direction
                                const directions = [
                                    () => { dotX = Math.max(5, dotX - stepSize); }, // Left
                                    () => { dotX = Math.min(95, dotX + stepSize); }, // Right
                                    () => { dotY = Math.max(5, dotY - stepSize); }, // Up
                                    () => { dotY = Math.min(95, dotY + stepSize); }  // Down
                                ];
                                
                                // Randomly choose one of the four directions
                                const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                                randomDirection();
                            }
                            
                            updateDotPosition();
                            checkWin();
                        }
                    });
                    
                    // Add on-screen arrow button event listeners
                    const arrowUp = document.getElementById('arrowUp');
                    const arrowDown = document.getElementById('arrowDown');
                    const arrowLeft = document.getElementById('arrowLeft');
                    const arrowRight = document.getElementById('arrowRight');
                    
                    function handleArrowClick(direction) {
                        if (controlsFixed) {
                            // Fixed pattern: normal controls
                            switch(direction) {
                                case 'ArrowLeft':
                                    dotX = Math.max(5, dotX - stepSize);
                                    break;
                                case 'ArrowRight':
                                    dotX = Math.min(95, dotX + stepSize);
                                    break;
                                case 'ArrowUp':
                                    dotY = Math.max(5, dotY - stepSize);
                                    break;
                                case 'ArrowDown':
                                    dotY = Math.min(95, dotY + stepSize);
                                    break;
                            }
                        } else {
                            // Confusing pattern: random direction
                            const directions = [
                                () => { dotX = Math.max(5, dotX - stepSize); }, // Left
                                () => { dotX = Math.min(95, dotX + stepSize); }, // Right
                                () => { dotY = Math.max(5, dotY - stepSize); }, // Up
                                () => { dotY = Math.min(95, dotY + stepSize); }  // Down
                            ];
                            
                            // Randomly choose one of the four directions
                            const randomDirection = directions[Math.floor(Math.random() * directions.length)];
                            randomDirection();
                        }
                        
                        updateDotPosition();
                        checkWin();
                    }
                    
                    // Add click event listeners for arrow buttons
                    if (arrowUp) arrowUp.addEventListener('click', () => handleArrowClick('ArrowUp'));
                    if (arrowDown) arrowDown.addEventListener('click', () => handleArrowClick('ArrowDown'));
                    if (arrowLeft) arrowLeft.addEventListener('click', () => handleArrowClick('ArrowLeft'));
                    if (arrowRight) arrowRight.addEventListener('click', () => handleArrowClick('ArrowRight'));
                    
                    // Add touch event listeners for mobile
                    if (arrowUp) arrowUp.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleArrowClick('ArrowUp');
                    });
                    if (arrowDown) arrowDown.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleArrowClick('ArrowDown');
                    });
                    if (arrowLeft) arrowLeft.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleArrowClick('ArrowLeft');
                    });
                    if (arrowRight) arrowRight.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        handleArrowClick('ArrowRight');
                    });
                    
                    // Initialize positions
                    moveTargetToRandomPosition();
                    
                    // Get target position and place red dot away from it
                    const target = document.getElementById('gameTarget');
                    const targetRect = target.getBoundingClientRect();
                    const gameAreaRect = gameArea.getBoundingClientRect();
                    
                    // Convert target position to percentage
                    const targetXPercent = ((targetRect.left - gameAreaRect.left) / gameAreaRect.width) * 100;
                    const targetYPercent = ((targetRect.top - gameAreaRect.top) / gameAreaRect.height) * 100;
                    
                    // Get position away from target
                    const safePos = getRandomPositionAwayFromTarget(targetXPercent, targetYPercent, 40);
                    dotX = safePos.x;
                    dotY = safePos.y;
                    updateDotPosition();
                }
            });
            

        </script>
</body>
</html>
